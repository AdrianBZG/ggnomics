---
title: "Rectangular Rugs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Rectangular Rugs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggplot2)
library(ggnomics)
library(GenomicRanges)
```

## What

To understand what rectangular rugs are, we must first remind ourselves what classic rugs are.

```{r}
df <- faithful
df$k <- as.factor(kmeans(df, 2)$cluster)

ggplot(df, aes(waiting, eruptions)) +
  geom_point() +
  geom_rug(aes(colour = k))
```

Classic rug plots display annotations of, typically, points in a 2D scatterplot in the margins of a plot. Above, we've indicated the results of a k-means clustering on the old faithful geyser data. Along the y-axis we can clearly see that the eruptions are bimodally distributed, by the increased density of 'tassels'. Since values mapped to the x-axis are integer counts, we cannot clearly distinguish the two densities.

Like ordinary rug plots can annotate points in a plot, rectangular rugs can annotate regions in a plot. This makes them particularly useful for annotating ranged or interval data.

## Why

I found myself frustrated with not having a good option to display ranged intervals of regions of interest. My data was non-negative, so my first thought was to just use rectangles with negative y-values to annotate regions. However, I found it quite tideous and inconsistent to do this for multiple plots. Especially when I wanted to show replicates of the same experiment in different facets this became quite gruesome. Hence, a ranged annotation in the margin would offer a solution.

## How

I'll walk you trough two example in which I've found rectangular rugs can be quite useful. The first example is annotation of specific regions in data that has 'peaks and valleys'-kind of structure and the second example is the annotation of correlation heatmaps.

### Heatmap annotation

```{r}
data <- iris[,1:4]
metadata <- data.frame(species = iris[,5],
                       z = seq_len(nrow(data)))
cors <- cor(t(data))
dist <- dist(data)
clust <- hclust(dist)

df <- reshape2::melt(cors[clust$order, clust$order])

g <- ggplot(df, aes(Var1, Var2, fill = value)) +
  geom_raster() +
  theme(aspect.ratio = 1)
```

```{r}
metadata$z <- metadata$z[order(clust$order)]

g +
  geom_tilerug(data = metadata,
               aes(z, z, fill = as.numeric(species)/3))
```


### ChIP-seq track annotation

To those who might not be familiar, a ChIP-seq experiment is essentially grabbing pieces of DNA that are bound by often a protein of interest. This is performed by fixing the DNA to the protein and then using antibodies specific for that protein to enrich for these pieces of DNA. The DNA that you obtain can then be unstuck from the protein and be sequenced and traced back from where in the genome it came from. If you find a lot of pieces of DNA from a particular region of the DNA, you can see a peak in the coverage data from which you can infer that the protein of interest must have been bound there.

Since I do not want to flood the repository with data, we'll generate some. To fake ChIP-seq data. We'll set up three peaks and some background reads.

```{r}
peaks <- GRanges("chr", 
                 IRanges(c(7000, 9500,  19000), 
                         c(7500, 10500, 21000)))
background <- GRanges("chr", IRanges(0, 30000))
nreads <- c(50, 1e2, 15e1, 1e2) # Last entry is for background
```

#### Generating a coverage track

We'll draw start positions for DNA sequencing reads by randomly drawing from cauchy distributions for peaks and from a uniform distribution as background or noise.

```{r}
peakstarts <- mapply(function(gr, n) {
  round(
    rcauchy(n,
            runif(n, start(gr), end(gr)),
            150)
  )
}, n = head(nreads, -1), gr = as.list(peaks))
peakstarts <- unlist(peakstarts)

bg <- round(
  runif(tail(nreads, 1), start(background), end(background))
)

readstarts <- c(unlist(peakstarts), bg)
```

Now we build reads by taking these start positions and sampling the width of the read fragment between 100 and 1000. Then, we'll take only the reads within the broader context of interest and calculate the coverage of this region.

```{r}
width <- sample(100:1000, sum(nreads), replace = TRUE)
gr <- GRanges(
  "chr", IRanges(readstarts, width = width)
  )

gr <- gr[overlapsAny(gr, background, type = "within")]
covr <- coverage(gr)[[1]]
```

With this coverage, we can parameterise a polygon to serve as our track.

```{r}
df <- data.frame(x = c(0, start(covr), end(covr), length(covr)),
                 y = c(0, runValue(covr), runValue(covr), 0))
df <- df[order(df$x),]
```

This polygon can be plotted as a basic plot.

```{r}
g <- ggplot(df, aes(x, y)) +
  geom_polygon() +
  scale_x_continuous(name = "Location") +
  scale_y_continuous(name = "Coverage")
g
```

#### Use of `geom_rectrug`

Now that we have a track, we would like to display the peaks from which the reads were drawn. In real life, you wouldn't know what the peaks are and specialised software is used to detect peaks. However, since this data was generated from peaks, we can show where these peaks are by using the `geom_rectrug` function.

```{r}
peaks <- as.data.frame(peaks)

g + geom_rectrug(data = peaks,
                 aes(xmin = start, xmax = end),
                 inherit.aes = FALSE)
```

